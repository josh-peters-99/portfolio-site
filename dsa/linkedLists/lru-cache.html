<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/htmx.org@2.0.6/dist/htmx.min.js" integrity="sha384-Akqfrbj/HpNVo8k11SXBb6TlBWmXXlYQrCSqEWmyKJe+hDm3Z/B2WVG4smwBkRVm" crossorigin="anonymous"></script>
    <link rel="stylesheet" type='text/css' href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
    <link href="../../prism/prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../base.css">
    <link rel="stylesheet" href="/portfolio-site/dsa/base-dsa.css">
    <link rel="icon" type="image/svg+xml" href="../../favicon.svg" />
    <title>Josh Peters</title>
    <script type="module" src="../../components/nav-component.js"></script>
    <script type="module" src="../../components/nav-mobile-component.js"></script>
    <script type="module" src="../../components/footer-component.js"></script>
</head>
<body>
    <header>
        <h1>Josh Peters</h1>
        <nav-bar></nav-bar>
        <nav-mobile></nav-mobile>
    </header>
    <main>
      <section>
        <h2 class="page-title">LRU Cache</h2>
        <p><b>Pattern: </b>Linked Lists, Hashmaps</p>
        <p><b>Problem: </b>
            Design and implement a data structure for the Least Recently Used (LRU) cache that supports the following operations:
            <ul>
              <li><code class="language-bash">LRUCache(int capacity)</code> Initialize the LRU cache with positive size <code class="language-bash">capacity</code></li>
              <li><code class="language-bash">int get(int key)</code> Return the value of the <code class="language-bash">key</code>. Return <code class="language-bash">-1</code> if the key doesn't exist.</li>
              <li><code class="language-bash">void put(int key, int value)</code> Add a key and its value to the cache or update the value of the <code class="language-bash">key</code> if it already exists. If the number of keys in the cache exceeds the <code class="language-bash">capacity</code>, evict the least recently used element.</li>
            </ul>
        </p>
        <p><b>Key Insight: </b>
            Below, is a visual of a LRU cache. In this example, the LRU cache currently holds 3 elements and has reached its full capacity. The key-value pairs are ordered from the least recently used (left) to the most recently used (right):
            <br><br>
            <div id="ascii-container">
                <pre class="ascii-code">
capacity = 3 
┌─────────────────────────────────────┐
│ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
│ │ 1 │ 100 │ │ 2 │ 200 │ │ 4 │ 400 │ │
│ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
└─────────────────────────────────────┘
──────────────────────────────────────►
least recently            most recently
used                      used
                </pre>
            </div>
            <p>Let's insert a new key-value pair into the cache:</p>
            <br><br>
            <div id="ascii-container">
              <pre class="ascii-code">
                      capacity = 3 
                      ┌─────────────────────────────────────┐
    ┌───┬─────┐       │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
put │ 3 │ 300 │ ────► │ │ 1 │ 100 │ │ 2 │ 200 │ │ 4 │ 400 │ │
    └───┴─────┘       │ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
                      └─────────────────────────────────────┘
                      ──────────────────────────────────────►
              </pre>
            </div>
            <p>
                The new key-value pair added to the cache will become the most recent in the cache, therefore we should add it the end of the cache. Since the cache is at maximum capacity, we must remove the least recently used pair. After the least recently pair has been evicted and the new pair added, the cache will look like this:
            </p>
            <br><br>
            <div id="ascii-container">
              <pre class="ascii-code">
┌─────────────────────────────────────┐
│ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
│ │ 2 │ 200 │ │ 4 │ 400 │ │ 3 │ 300 │ │
│ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
└─────────────────────────────────────┘
──────────────────────────────────────►
              </pre>
            </div>
            <p>
              The <code class="language-bash">put</code> operation can be summarized with following steps:
              <ol>
                <li>Remove the least recently used key-value pair from the cache.</li>
                <li>Add the new key-value pair to the most recently used end of the the cache.</li>
              </ol>
            </p>
            <br><br>
            <p>To perform a <code class="language-bash">get</code> operation, the key-value pair we access will become the most recently used pair:</p>
            <br><br>
            <div id="ascii-container">
              <pre class="ascii-code">
                    move to most recently used end
                    ┌──────────────────────────────┐
                    │                              │
             ┌──────│──────────────────────────────│─┐
             │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │ │
get(2) ────► │ │ 2 │ 200 │ │ 4 │ 400 │ │ 3 │ 300 │ ▼ │
             │ └───┴─────┘ └───┴─────┘ └───┴─────┘   │
             └───────────────────────────────────────┘
             ────────────────────────────────────────►

             ┌─────────────────────────────────────┐
             │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
             │ │ 4 │ 400 │ │ 3 │ 300 │ │ 2 │ 200 │ │ ────► return 200
             │ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
             └─────────────────────────────────────┘
             ──────────────────────────────────────►
              </pre>
            </div>
            <p>
              The <code class="language-bash">get</code> operation can be summarized with the following steps:
              <ol>
                <li>Move the key-value pair that is being retrieved to the most recently used end of the cache.</li>
                <li>Return the value of the key-value pair.</li>
            </p>
            <p>
            To perform the <code class="language-bash">put</code> and <code class="language-bash">get</code> operations, we need to add or remove elements efficiently. The linked list is the best data structure for accomplishing this. Now, should we use a singly linked list or a doubly linked list? Regardless of which one we choose, the time complexity of adding or removing pairs from the head of the list will be <i>O(1)</i>. However, if we need to add or remove a pair from the tail of the list then utilizing a singly linked list will result in a time complexity of <i>O(n)</i> because we will have to traverse the entire list to reach the tail. This is why we will select to use the doubly linked list. Utlizing the doubly linked list will allow us to add or remove a pair from the tail of the list with a time complexity of <i>O(1)</i>.
            </p>
            <p>
            We will need to create a <code class="language-bash">head</code> and <code class="language-bash">tail</code> node that will allow us to add and remove nodes from the ends of the cache.
            <br><br>
              <div id="ascii-container">
                <pre class="ascii-code">
capacity = 3 
┌────────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌────────┐
│  head  │      │ 4 │ 400 │      │ 3 │ 300 │      │ 2 │ 200 │      │  tail  │
└────────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └────────┘
                </pre>
              </div>
            </p>
            <p>
            Performing operations on nodes at the ends of the cache is quick and easy but to perform operations on the nodes in the middle would require use to traverse the linked list until we reach the desired node. To access nodes at any location in the linked list in <i>O(1)</i> time we can use a hashmap to store the pre-existing key-value pairs. This allows us to access a node by its key in constant time.
            <br><br>
            </p>
            <div id="ascii-container">
              <pre class="ascii-code">
┌────────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌────────┐
│  head  │      │ 4 │ 400 │      │ 3 │ 300 │      │ 2 │ 200 │      │  tail  │
└────────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └────────┘
                    ▲                ▲                ▲  
                    │                │                │
                    └─────┐          └────────┐       └───────────┐
                          │                   │                   │
hashmap: {(key: 4, value: •), (key: 3, value: •), (key: 2, value: •)}
              </pre>
            </div>
            <p>
            Below is a visual to understand the logic used to add a new key-value pair to the cache:
            </p>
            <br><br>
            <div id="ascii-container">
              <pre class="ascii-code">
                  ┌──────────────────────────────────────────┐
                  │ Does the key already exist in the cache? │
                  │ Verify by querying the hash map.         │
                  └──────────────────────────────────────────┘
              ┌────────── Yes ─────────┴────── No ──────┐
              │                                         │
              ▼                                         ▼
┌─────────────────────────────┐            ┌─────────────────────────┐
│ Remove this key's node from │            │ Would adding a new node │
│ the linked list.            │            │ exceed capacity?        │
└─────────────────────────────┘            └─────────────────────────┘
              └───────────────┐   ┌───────── No ────────┴─ Yes ──┐
                              │   │                              │
                              │   │                              ▼
                              │   │          ┌─────────────────────────────────────┐ 
                              │   │          │ 1. Remove the least recently used   │
                              │   │   ┌──────│    node from the linked list.       │
                              │   │   │      │ 2. Remove it from the hash map too. │
                              │   │   │      └─────────────────────────────────────┘
                              │   │   │
                              │   │   │
                              ▼   ▼   ▼
               ┌──────────────────────────────────────┐
               │ 1. Add the node as the most recently │
               │    used node of the linked list.     │
               │ 2. Add it to the hash map too.       │
               └──────────────────────────────────────┘
              </pre>
            </div>
            <p>
            Below is the process for retrieving a key's value from the cache:
            </p>
            <div id="ascii-container">
              <pre class="ascii-code">
                  ┌──────────────────────────────────────────┐
                  │ Does the key already exist in the cache? │
                  │ Verify by querying the hash map.         │
                  └──────────────────────────────────────────┘
                      ┌──── Yes ──────┴────── No ─────┐
                      │                               │
                      ▼                               ▼
┌─────────────────────────────────────────────┐  ┌───────────┐
│ Make the node at this key the most recently │  │ Return -1 │
│ used through the following steps:           │  └───────────┘
│                                             │
│ 1. Remove the node.                         │
│ 2. Add the node as the most recently used   │
│    node of the linked list.                 │
└─────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────┐
│ Return the value associated with this node. │
└─────────────────────────────────────────────┘ 
              </pre>
            </div>
            <p>
            Let's now begin to explore the process of implementing the helper functions &#8212; <code class="language-bash">addToTail</code> and <code class="language-bash">removeNode</code>.
            </p>
            <p>
            We will start with <code class="language-bash">addToTail</code>. Below is a visual that explains the process of adding a node to the cache:
            </p>
            <div id="ascii-container">
              <pre class="ascii-code">
                                        ┌───┬─────┐
                              addToTail │ 3 │ 300 │
                                        └───┴─────┘
                                             │
                                             ▼
┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌──────┐
│ head │      │ 2 │ 200 │      │ 4 │ 400 │      │ tail │
└──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └──────┘
                               prevNode

                                        ┌───┬─────┐
                                     ┌──┤ 3 │ 300 ├─┐
                                     │  └───┴─────┘ │
                                     │    ▲    ▲    │
                                     ▼    │    │    ▼
┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐│    │┌──────┐
│ head │      │ 2 │ 200 │      │ 4 │ 400 ├┘    └┤ tail │
└──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘      └──────┘
                               prevNode
              </pre>
            </div>
            <p>
            Below is a visual for the process of removing a node using the <code class="language-bash">removeNode</code> helper function:
            </p>
            <div id="ascii-container">
              <pre class="ascii-code">
                                ┌───┬─────┐
                     removeNode │ 4 │ 400 │
                                └───┴─────┘
                                    │
                                    ▼
┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌──────┐
│ head │      │ 2 │ 200 │      │ 4 │ 400 │      │ 3 │ 300 │      │ tail │
└──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └──────┘


                    ┌────────────────────────────────┐
                    │                                ▼
┌──────┐ ───► ┌───┬─┴───┐ ---► ┌---------┐ ---► ┌───┬─────┐ ───► ┌──────┐
│ head │      │ 2 │ 200 │      | 4 │ 400 |      │ 3 │ 300 │      │ tail │
└──────┘ ◄─── └───┴─────┘ ◄--- └---------┘ ◄--- └───┴┬────┘ ◄─── └──────┘
                   ▲                                 │
                   └─────────────────────────────────┘
              </pre>
            </div>
        </p>
        <p><b>Time Complexity: </b>Both helper functions have a time complexity of <i>O(1)</i>. The <code class="language-bash">put</code> and <code class="language-bash">get</code> functions both use the helper functions. Therefore, <i>O(1)</i> is the time complexity.</p>
        <p><b>Space Complexity: </b>The overall space complexity is <i>O(n)</i> where <i>n</i> is the capacity size of the cache.</p>
        <p><b>Code:</b></p>
        <pre>
            <code class="language-go">
type DoublyLinkedListNode struct {
    key  int
    val  int
    next *DoublyLinkedListNode
    prev *DoublyLinkedListNode
}

type LRUCache struct {
    capacity int
    cache    map[int]*DoublyLinkedListNode
    head     *DoublyLinkedListNode
    tail     *DoublyLinkedListNode
}


func Constructor(capacity int) LRUCache {
    head := &DoublyLinkedListNode{key: -1, val: -1}
    tail := &DoublyLinkedListNode{key: -1, val: -1}
    head.next = tail
    tail.prev = head

    return LRUCache {
        capacity: capacity,
        cache: make(map[int]*DoublyLinkedListNode),
        head: head,
        tail: tail,
    }
}

func (this *LRUCache) addToTail(node *DoublyLinkedListNode) {
    prev := this.tail.prev
    prev.next = node
    node.prev = prev
    node.next = this.tail
    this.tail.prev = node
}

func (this *LRUCache) removeNode(node *DoublyLinkedListNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) Get(key int) int {
    if node, exists := this.cache[key]; exists {
        this.removeNode(node)
        this.addToTail(node)
        return node.val
    }
    return -1
}


func (this *LRUCache) Put(key int, value int)  {
    if node, exists := this.cache[key]; exists {
        this.removeNode(node)
    }
    newNode := &DoublyLinkedListNode{key: key, val: value}
    this.cache[key] = newNode
    this.addToTail(newNode)

    if len(this.cache) > this.capacity {
        lru := this.head.next
        this.removeNode(lru)
        delete(this.cache, lru.key)
    }
}
            </code>
        </pre>
      </section>
    </main>
    <footer-component></footer-component>
    <script src="../../prism/prism.js"></script>
</body>
</html>
